Evaluation of mesutgenai/loom-mvn as an Agent-
Oriented “Email Protocol” Replacement
Executive summary
Enabled connectors used: GitHub       1   (repository contents, including specs and source code)


Verdict: Needs work — promising as an “agent-email” foundation inside controlled environments (single org,
consortium, or curated federation), but not yet suitable as a general-purpose, Internet-replacement “new email
protocol for agents” without substantial protocol hardening, interoperability work, and security/privacy controls.


Why this is the verdict

The repository implements a coherent “email-like” model for agents (threads, participants, attachments,
receipts, store-and-forward outboxes, gateways to SMTP/IMAP) and adds agent-centric primitives
(delegation chains, capability tokens, signed delivery wrappers). The design is conceptually aligned with
“agent email” and meaningfully improves on classic email’s weak end-to-end authenticity and authorization
model.


At the same time, the current solution is not a drop-in replacement for the global email ecosystem (SMTP/
IMAP/POP3, RFC 5322 message model, operational anti-abuse expectations), and it does not yet match the
maturity of existing agent messaging protocols (e.g., DIDComm’s identity/key model and encryption
packaging, ActivityPub’s federation semantics, and the long-standing ACL performative/message semantics
in FIPA specifications). In particular, the identity trust anchor + key lifecycle, strong security posture
under federation and bridging, and interoperability conformance remain under-specified or rely on
assumptions that are plausible in private deployments but fragile at Internet scale.


Top five prioritized recommendations

Establish a trust anchor and key lifecycle policy (rotation, revocation, persistence, and auditability)
(effort: High).
The node’s federation keys and system keys are central to identity signatures, receipts, and wrapper
signatures; a “new email protocol” must have a crisp trust model comparable to “DNS + WebPKI + DKIM/
SPF/DMARC” in email. The RFC ecosystem for email authentication exists precisely because authentication
and replay/impersonation are hard at scale. 2


Publish canonical test vectors and conformance tests for signing/canonicalization across languages
(effort: Medium).
You already implement a canonical JSON strategy and Ed25519 signatures, but interoperability only holds if
independent implementations produce identical bytes for signatures. Canonical JSON has a formal standard
(RFC 8785) and should be validated with test vectors. 3




                                                        1
Complete (or explicitly defer) end-to-end encryption profiles and key agreement semantics (effort:
High).
If the goal is an “email-like” protocol for agents, confidentiality and forward secrecy are essential
expectations (especially for autonomous agents that may exchange sensitive tool outputs). DIDComm is a
useful reference point for packaging and crypto negotiations. 4


Harden the email bridging + gateway boundary to avoid “email-smuggling” risks and semantics drift
(effort: High).
The system parses RFC 822/5322-ish text and maps it into LOOM threads and envelopes. Internet email
message format and delivery rules are complex (header folding, multipart MIME, DSNs, idiosyncratic client
behavior), and partial support can become a security and reliability liability. 5


Operationalize scalability and abuse resistance beyond “MVP node” assumptions (effort: Medium–
High).
A new “agent email” network will be attacked: spam, credential stuffing, federation abuse, and resource
exhaustion. Email’s history is instructive: SMTP became spam-prone without authentication and policy
layers; modern deployments depend heavily on abuse mitigation. 6


Repository scope and goals with assumptions

What the project is building

The repository positions LOOM MVN (Minimum Viable Node) as a reference implementation of a signed,
federated, email-like messaging layer for humans and agents. The repo contains: - A LOOM protocol
specification ( LOOM-Protocol-Spec-v1.1.md ) and earlier design/spec docs. - A node implementation
with   in-memory      state    plus   persistence       options   ( src/node/store.js ,      src/node/
persistence_postgres.js ). - A federation subsystem (signed HTTP delivery, node bootstrap via
/.well-known/loom.json , remote identity resolution, receipts, abuse policies). - Bridging/gateways: -
SMTP/IMAP “wire gateway” ( src/node/wire_gateway.js ) to support legacy email clients and
workflows. - Email relay integration ( src/node/email_relay.js ) to send outbound mail via SMTP
providers and optionally DKIM-sign. - Inbound email ingestion into LOOM envelopes (bridge logic inside
 src/node/store.js ).


Evidence from repository artifacts

Protocol-as-code orientation. The LOOM envelope model is enforced in code: - Envelope validation and
schema checks: src/protocol/envelope.js . - Canonical JSON canonicalization: src/protocol/
canonical.js . - Sign/verify operations referenced by the node store: src/node/store.js imports
signEnvelope , verifyEnvelopeSignature , etc.


Threaded “email-like” semantics. The node uses a thread DAG with ordered envelopes, mailbox state
(seen/flagged/archived/deleted), and IMAP folder mapping (INBOX/Sent/Archive/Spam/Trash/Quarantine/
Drafts). This is implemented in src/node/store.js and surfaced through the IMAP gateway ( src/
node/wire_gateway.js ).




                                                    2
Federation and identity resolution. The node stores “known nodes” and can bootstrap them via a
 .well-known document, then uses those node keys to verify remote identity documents and delivery
receipts: - Federation request signing/verifying is done via canonical strings built from method/path/body-
hash/timestamp/nonce, with replay protection at the nonce-cache layer ( src/node/store.js ). - Node
documents include deliver_url and identity_resolve_url , plus federation signing keys ( src/
node/store.js ).


Unstated or loosely stated assumptions

These choices are reasonable for a reference node, but they are important assumptions if this becomes
“agent email” infrastructure:


Assumption about identity namespace. The code treats identities as loom://<email-like> URIs and
extracts the “domain” after @ to determine federation authority ( parseLoomIdentityDomain and
assertFederatedEnvelopeIdentityAuthority in src/node/store.js ). That effectively assumes: -
identities are globally unique and DNS-ish (domain-like), - a domain maps cleanly to a single authority node
ID, and - the authority node is the correct trust anchor for identity keys.


Assumption about time sync and replay windows. Federation freshness checks enforce a narrow
timestamp window (±5 minutes) and nonce replay detection ( verifyFederationRequest in src/node/
store.js ). This presumes reliable clock sync (e.g., NTP) across nodes and stable request delivery latencies.


Assumption about gateway parsing completeness. The SMTP gateway parses “RFC822-like” text via a
minimal parser ( parseRfc822 in src/node/wire_gateway.js ). This assumes “good enough” parsing
for real-world email, but Internet email and MIME are much more complex.      7




Assumption about inbound email authenticity signals. Email bridging relies on “Authentication-Results”
style    signals   (SPF/DKIM/DMARC)     supplied      either      in     payload      or      headers
( resolveBridgeInboundAuthResults    /    evaluateBridgeInboundAuthPolicy            in    src/node/
store.js ). In real deployments, correctness depends heavily on upstream MTA configuration and trust
boundaries.   8




Assumption about storage and privacy. The node stores full message bodies and attachments (base64) in
state or persistence; there is no default “always encrypted at rest” posture in code. This matters in any
regulated or sensitive environment.


Architecture and data flows

Components and responsibilities in the current repo

The implementation coalesces into a few core components:


Node store (“authoritative state machine”).
 src/node/store.js is the central state manager: identities (local + cached remote), keys, threads,
envelopes, mailbox state, capabilities, delegations, outboxes (federation/email/webhook), and audit chain.




                                                     3
HTTP API server.
 src/node/server.js       wires HTTP endpoints (e.g., identity registration/challenge, envelope ingest,
thread views, federation deliver/challenge, bridge ingress/egress, metrics/status).


Wire gateway (SMTP + IMAP).
src/node/wire_gateway.js runs TCP servers speaking subset SMTP and IMAP commands and maps
them to store operations ( store.submitGatewaySmtp , store.listGatewayImapMessages , mailbox
state mutations).


Persistence backends.
- Disk snapshot + JSONL audit log (built into store.js ). - Postgres persistence adapter ( src/node/
persistence_postgres.js )        referenced    by    store.persistenceAdapter         with   functions   like
loadStateAndAudit ,       persistSnapshotAndAudit , and distributed guards for rate limits/outbox
claims.


Email relay integration.
 src/node/email_relay.js sends outbound mail for bridged flows (and supports provider responses
and DSN-like update ingestion via applyEmailOutboxDsnReport in store.js ).


Mermaid diagram of major components


  flowchart LR
    subgraph Clients
      A1[LOOM-native agent/client\nHTTP + WS]
      A2[Legacy email client\nSMTP/IMAP]
      A3[Remote LOOM node\nFederation HTTP]
      A4[External mail infra\nSMTP relays/MX]
    end

    subgraph LoomNode["LOOM MVN Node"]
      S1[HTTP API server\nsrc/node/server.js]
      S2[Core store/state machine\nsrc/node/store.js]
      S3[Wire gateway\nSMTP+IMAP\nsrc/node/wire_gateway.js]
      S4[Email relay adapter\nsrc/node/email_relay.js]
      S5[Persistence adapter\nPostgres\nsrc/node/persistence_postgres.js]
      S6[Disk snapshot + audit log\nstate.json + audit.log.jsonl]
    end

    A1 -->|REST/WS| S1
    S1 --> S2

    A2 -->|SMTP submit| S3
    A2 -->|IMAP read/flags| S3
    S3 --> S2

    S2 -->|federation outbox| A3




                                                      4
       A3 -->|/v1/federation/deliver| S1

       S2 -->|email outbox| S4
       S4 -->|SMTP| A4


       S2 <--> S5
       S2 <--> S6


Architectural observations and issues

Single massive “god object” store. src/node/store.js is a monolith spanning: - security checks
(replay, SSRF protections, signature verification), - business logic (thread DAG, mailbox state), - protocol
adapters (email header parsing, rendering outbound email), - persistence orchestration (flush queues,
backup/restore), - outbox processing and retry policies.


This makes the system easy to run as a single binary, but harder to maintain, test, and independently scale.
For “agent email” infrastructure, you will likely want: - clear module boundaries (protocol core vs adapters vs
policy engine), - stable interfaces, and - a test-driven conformance suite for each surface.


Protocol design and standards alignment

LOOM message format and delivery semantics (as implemented)

Envelope structure and validation (core)

The envelope is JSON with: - loom version, - IDs ( id , thread_id , parent_id ), - type (e.g.,
message , thread_op ), - sender ( from.identity , from.key_id , from.type ), - recipients ( to[]
with roles), - audience.mode ( thread vs recipients for BCC-like behavior), - content ( human +
structured , optional encrypted flag), - attachments (LOOM blobs), - signature object ( algorithm ,
key_id , value ).


This    is   enforced   in   src/protocol/envelope.js         and   then   checked    again   contextually   in
store.ingestEnvelope() : - signature verified before quotas/rate limits are charged (good anti-abuse
ordering), - agent senders require delegation chain verification ( verifyDelegationChainOrThrow ), -
thread DAG is validated to avoid cycles ( validateThreadDag ), - BCC privacy is enforced through delivery
wrappers.


Concrete example of federation request signing canonical form (HTTP-level) in src/node/store.js :



  const canonical = `POST\n${parsedUrl.pathname}\n${bodyHash}\n${timestamp}\n$
  {nonce}`;
  const signature = signUtf8Message(this.federationSigningPrivateKeyPem,
  canonical);




                                                      5
Routing model

     • Within a node: envelopes are added to a thread; participants determine visibility.
     • Across nodes: federation relies on:
     • node discovery (default https://<node_id>/.well-known/loom.json ),
     • deliver_url (default https://<node_id>/v1/federation/deliver ),
     • remote identity resolution endpoint ( /v1/identity/{identity} by default),
     • signed federation requests and optional signed receipts.

The routing assumption is “node_id ~ DNS domain”. This is conceptually email-like, but not equivalent to
SMTP relaying semantics.


Delivery semantics

LOOM delivers envelopes by pushing batches to remote nodes and expecting a JSON receipt with accepted
IDs. This resembles an application-layer “federation POST” rather than SMTP’s store-and-forward relay
network. SMTP’s semantics, queueing, retries, and DSN behaviors are well-defined at the transport layer for
email. 9


LOOM does implement: - outbox retry with exponential backoff and max attempts
( processFederationOutboxItem , markOutboxFailure in src/node/store.js ), - idempotency
keys for certain actions (idempotency cache in store.js ), - signed delivery receipts when configured
( createFederationDeliveryReceipt , verifyFederationDeliveryReceipt ).


Compatibility vs SMTP/IMAP/POP3 and RFC 5322

SMTP alignment

The repository includes an SMTP server in          src/node/wire_gateway.js          implementing: - basic
commands: EHLO/HELO, MAIL FROM, RCPT TO, DATA, RSET, QUIT, - AUTH mechanisms: PLAIN, LOGIN,
XOAUTH2 (token-based), - STARTTLS upgrade support when TLS is enabled.


SMTP itself is defined by RFC 5321, and authentication/authorization is typically provided by SASL + policy at
deployment time. 10
This gateway is pragmatic, but it is not a full SMTP MTA and doesn’t attempt to replicate SMTP’s relay
ecosystem.


IMAP alignment

The IMAP server in src/node/wire_gateway.js advertises IMAP4rev1 capabilities and supports a
partial set of commands: - CAPABILITY, LOGIN/AUTHENTICATE (PLAIN), LIST/LSUB, SELECT/EXAMINE, -
FETCH/UID FETCH, STORE/UID STORE, SEARCH/UID SEARCH, - MOVE (but explicitly not COPY), IDLE,
EXPUNGE (as a no-op compatibility behavior), CLOSE/UNSELECT.


IMAP is standardized (current revision IMAP4rev2 is RFC 9051). 11
The implementation itself notes gaps (e.g., APPEND literal syntax unsupported; COPY unsupported;




                                                      6
“minimal parser does not implement boolean group operators” for search). These gaps matter for real
clients.


POP3

There is no POP3 server in this repository. POP3 is defined in RFC 1939. 12
If “email protocol for agents” must integrate broadly with legacy clients, POP3 absence is acceptable (many
modern clients do IMAP), but it should be explicitly documented as out-of-scope.


RFC 5322 message model

The SMTP gateway parses messages using a simplified header/body split and basic header unfolding
( parseRfc822 in wire_gateway.js ). True Internet Message Format is RFC 5322 and includes
complexities (folding, structured header fields, MIME layering via other RFCs). 13
This implies: - incomplete fidelity for multipart email, attachments, and internationalized headers, -
potential mis-threading due to partial Message-ID , References , In-Reply-To handling, - risk of
“semantic drift” when round-tripping between LOOM and email.


Compatibility vs agent messaging protocols (FIPA, ActivityPub, DIDComm)

FIPA ACL

FIPA ACL (Agent Communication Language) defines performative-based message semantics and content
language negotiation (historically used in agent platforms). 14
LOOM’s       content.structured.intent                 resembles an   “intent   label”     (e.g.,
thread.add_participant@v1 , message.general@v1 ) but does not implement: - ACL performatives
(request, inform, propose, etc.), - formal content language / ontology declarations, - conversation-id
semantics as formalized in ACL frameworks.


Practical implication: LOOM is not an ACL-compatible protocol; adapters would need to map LOOM intents +
parameters to ACL performatives and vice versa (with inevitable information loss unless LOOM adds explicit
ACL fields).


ActivityPub

ActivityPub is a W3C recommendation for decentralized social networking, built around Actors, Inbox/
Outbox endpoints, and ActivityStreams objects. 15
LOOM federation is structurally similar (server-to-server delivery, signed objects), but mismatch areas
include: - ActivityPub’s Actor model and object vocabulary (JSON-LD / ActivityStreams) vs LOOM’s envelope +
thread DAG, - ActivityPub’s standard endpoints and HTTP interaction patterns vs LOOM’s bespoke /v1/
federation/deliver + receipts, - compatibility with the broader Fediverse tooling ecosystem.


An adapter could exist, but LOOM is not a “subset of ActivityPub” and cannot interoperate without
translation.




                                                    7
DIDComm

DIDComm Messaging v2 provides an identity/key management model based on decentralized identifiers,
plus message packing mechanisms (authenticated encryption, routing) intended for interoperable secure
messaging. 4
LOOM overlaps in spirit (cryptographic authenticity, agent-to-agent messaging), but key mismatches are: -
LOOM identity URIs are not DIDs; there is no DID resolution surface. - LOOM’s signing is envelope-level with
node/identity keys, but E2E encryption profiles are not clearly implemented in the repository (beyond
 encrypted: false/true flags and placeholders). - DIDComm includes routing/mediators patterns;
LOOM’s routing is federated HTTP between nodes.


If “agent email protocol” requires modern secure messaging guarantees, DIDComm is a strong comparative
bar: LOOM should either adopt DID-based identity resolution or clearly define an alternative trust anchor
(e.g., DNS + WebPKI + signed node docs).


Protocol flow diagrams

Federation delivery flow


  sequenceDiagram
    participant NodeA as Sender node (A)
    participant NodeB as Recipient node (B)
    participant StoreA as Store(A)
    participant StoreB as Store(B)

    StoreA->>StoreA: Queue federation outbox\n(envelope_ids, deliver_url,
  attempts, next_attempt_at)
    Note over StoreA: Canonical wrapper JSON\nincludes envelopes[]
    NodeA->>NodeB: POST /v1/federation/deliver\nHeaders: x-loom-node, x-loom-
  timestamp,\n x-loom-nonce, x-loom-key-id, x-loom-signature\nBody: {loom,
  sender_node, delivery_id, envelopes[]}
    NodeB->>StoreB: verifyFederationRequest()\n(timestamps, nonce replay,
  signature)
    StoreB->>StoreB: For each envelope:\n- ensureFederatedSenderIdentity()\n-
  verifyEnvelopeSignature()\n- ingestEnvelope()
    StoreB-->>NodeB: Build signed receipt\n(accepted ids, status)
    NodeB-->>NodeA: 200 OK {receipt, accepted_count,...}
    NodeA->>StoreA: Verify receipt (optional)\nMark outbox delivered or retry


Email inbound bridge flow


  sequenceDiagram
    participant MTA as Upstream MTA / parser
    participant API as LOOM HTTP API
    participant Store as LoomStore




                                                     8
    MTA->>API: POST /v1/bridge/email/inbound\n(payload headers/body/auth_results)
    API->>Store: createBridgeInboundEnvelope()
    Store->>Store: Evaluate auth_results:\nSPF/DKIM/DMARC policy\n(reject/
  quarantine)
    Store->>Store: Map to envelope:\nfrom = bridge://smtp_from\nthread_id via
  Message-ID/References\ncontent.human/text\nsign with system key
    Store-->>API: {envelope_id, thread_id, quarantined}
    API-->>MTA: 200 OK or 403 reject



Security, privacy, and compliance evaluation

Authentication and authorization

Identity authentication (LOOM-native).
The      node     implements     a     challenge-based          auth      for      local     identities:   -
 createAuthChallenge({         identity,        key_id            })        issues       a      nonce.     -
exchangeAuthToken({ identity, key_id, challenge_id, signature }) verifies the signature
on the nonce and returns bearer access/refresh tokens. - Tokens are stored in memory with expirations
( accessTokens , refreshTokens ) and used by gateways and HTTP routes.


This is a coherent design for a reference node. Security posture depends on TLS and token protection (see
below).


Gateway authentication.
SMTP and IMAP gateways authenticate via bearer token values embedded in SASL payloads (PLAIN/LOGIN/
XOAUTH2). The gateway enforces: - “encryption required” if auth is enabled but insecure auth is not allowed,
- STARTTLS gating (and refuses unsafe configurations), e.g.:



  if (this.enabled && this.requireAuth && !this.allowInsecureAuth && !
  this.tlsEnabled) {
    throw new Error("Refusing authenticated wire gateway without TLS; ...");
  }


(from src/node/wire_gateway.js )


Cryptography choices and issues

Ed25519 signatures.
The system uses Ed25519 as its signature algorithm (envelope signature objects indicate algorithm:
"Ed25519" ). This is a modern choice with a standardized spec (RFC 8032).   16




Canonical JSON for signatures.
Canonicalization is central to signature stability, and the repo includes a canonicalizer in src/protocol/




                                                     9
canonical.js . Canonical JSON has an RFC standard (RFC 8785) and should be treated as a strict
interoperability contract.   17




Key format mismatch risk.
In practice, the node identity documents and node documents in src/node/store.js expect keys in
PEM form ( public_key_pem ). This is workable, but if any spec text or ecosystem expects base64url keys
or JWK, you need a single canonical representation plus conversion rules.


Replay protection, abuse mitigation, and SSRF controls

Replay protection (federation).
 verifyFederationRequest enforces: - a timestamp freshness window, - a nonce cache keyed by
nodeId:nonce , - optional distributed guard support through persistence adapter APIs.


This is a solid baseline for HTTP-level replay protection.


Rate limits and quotas.
 src/node/store.js implements: - per-identity request rate windows (default vs sensitive routes), -
envelope daily quota, - blob daily quota and byte quota, - federation inbound node/global rate windows.


Spam/abuse mitigation.
The store contains a federation abuse auto-policy engine: - counts failures per node over a window, -
escalates to “quarantine” or “deny” policies, - optionally requires a “challenge token” for nodes with elevated
abuse signals.


This is a strong direction, but it is not equivalent to decades of email anti-spam mechanisms (reputation
networks, content filtering, domain authentication enforcement). Historically, SMTP required DKIM/SPF/
DMARC layers to even begin resisting spoofing and spam. 2


SSRF and outbound pinning controls.
A notable positive: the store implements outbound URL checks and DNS pinning to reduce SSRF risk and
metadata service access: - denylist includes common metadata hostnames and link-local metadata IPs, - can
enforce host allowlists, - resolves DNS and rejects private/local targets unless explicitly allowed, - can reject
redirects.


This is a meaningful control for webhooks, federation bootstrap, and remote identity resolution.


Privacy and data protection considerations

Data stored includes message bodies, headers, and attachments. - Inbound mail bridge stores
 original_headers and auth_results in meta.bridge . - Attachments are stored in base64 in
blobs. - Audit logs encode action payloads and can include trace IDs / request IDs.


This has GDPR and general privacy implications: - retention policy requirements, - access control and audit
access segregation, - right-to-erasure workflows, - encryption-at-rest expectations, - breach impact scope.




                                                       10
Email ecosystems often treat message content as highly sensitive. For compliance readiness (GDPR/industry
standards), “at rest encryption + retention + deletion” policies should be explicit and testable.


Threat model maturity

The repository includes a threat model doc and a production readiness doc ( docs/THREAT-MODEL.md ,
docs/PRODUCTION-READINESS.md ). This is a strong sign of deliberate engineering. However: - the
inability to retrieve docs/RATE-LIMIT-POLICY.md via the connector (tooling block) means parts of
operational policy documentation could not be directly verified here; conclusions rely on code-level rate
limiting and quotas instead.


Interoperability, performance, reliability, and maintainability

Interoperability requirements and needed gateways/adapters

Integration with existing email infrastructure

To interoperate with classic email clients and MTAs, LOOM MVN currently offers: - SMTP submit + IMAP
read/update via LoomWireGateway . - Outbound email relay support via email_relay path and email
outbox   processing. -   Inbound            “email    →     LOOM”         ingress   via   bridge   functions
( createBridgeInboundEnvelope ).


However, the mapping is “best-effort” and not equivalent to full RFC 5322 + MIME fidelity.   7




Required adapters/gateways for full enterprise compatibility - A robust MIME parser/renderer
(multipart/attachments) aligned with common MTAs and clients. - Optional POP3 gateway if required by
legacy tooling. 12 - DKIM/SPF/DMARC enforcement integration (ideally at the MTA boundary), with clear
trust model for Authentication-Results headers. 2


Integration with agent frameworks

To interoperate with agent ecosystems, you would likely need: - FIPA ACL adapter: map LOOM intent
and parameters to ACL performatives and content languages.           14    - ActivityPub adapter: map LOOM
threads/envelopes to ActivityStreams objects, define Actor mapping. 15 - DIDComm adapter or native
DID support: DID-based identity resolution, encryption packaging, mediation/routing patterns. 4


Performance, scalability, and reliability

Current strengths - Outbox processing uses retries with exponential backoff and max attempts
(federation/email/webhooks) in src/node/store.js . - There is a claim/lease mechanism for outbox
items,   with   optional    backing    by   persistence    adapter    ( claimOutboxItemForProcessing ,
releaseOutboxItemClaim ). - There are multiple quota levers: blob size/parts, fanout caps, envelope/day
quotas, and outbox backpressure.


Scaling risks - The in-memory maps in the store ( envelopesById , threadsById , blobsById , etc.)
imply memory growth proportional to history unless retention/purging is implemented and enforced. -




                                                     11
Search is linear scan over envelopes for a participant ( searchEnvelopes ), which will not scale without
indexing. - IMAP gateway truncates message lists to a bounded number (it frequently uses 1000 limits); this
is pragmatic but will surprise clients expecting full mailbox access.


Failure modes to plan for - Process restart: state persistence is optional; if misconfigured, key material and
verification continuity can break. - Partial federation deliveries: receipts mark accepted/rejected; depending
on require_signed_receipts , delivery can fail and retry even if remote accepted but receipt verify
failed. - Bridge failures: inbound email auth results incorrect → reject/quarantine; either can cause message
loss or “silent quarantine” backlog.


Developer experience and maintainability

Positives - The code demonstrates systematic error handling ( LoomError with codes/status). - Built-in
operational hooks: audit chain, backup/restore, guard status, outbox stats, and webhook delivery flows.


Key maintainability concern - src/node/store.js is an extremely large multi-domain module. This
makes it difficult to: - unit test protocol logic independently from storage and adapters, - reason about
security boundaries, - replace components (e.g., swap email parsing) without regression risk.


CI/tests visibility - Repository issue/PR search returned no results via connector search. This limits
evidence about active review workflows and test culture from issues/PRs alone. - The production readiness
doc references additional artifacts, but only a subset was explicitly requested and retrievable in this
analysis.


Standards comparison tables and prioritized action plan

Design vs standards/protocols comparison

                     LOOM MVN design           Standard
 Area                                                              Primary gaps / mismatches
                     (repo)                    baseline

                     SMTP submit gateway                           Not an SMTP relay network; gateway is
 Email                                         SMTP (RFC
                     (subset) + HTTP                               “submit into LOOM,” not full mail
 transport                                     5321)
                     federation                                    transfer with MX semantics. 10

                                               RFC 5322
                     Minimal RFC822
 Email message                                 Internet            MIME + header edge cases not
                     parsing + LOOM JSON
 format                                        Message             covered; round-trip fidelity risks.   13
                     envelopes
                                               Format

                                                                   COPY unsupported, literal APPEND
                     IMAP subset with
                                               IMAP4rev2 (RFC      unsupported, SEARCH limited; some
 Mail access         LOOM folder
                                               9051)               IMAP behaviors are compatibility no-
                     mapping
                                                                   ops. 11

                                               POP3 (RFC           POP3 clients cannot interoperate
 POP3 access         Not implemented
                                               1939)               without new gateway. 12




                                                     12
                      LOOM MVN design           Standard
 Area                                                               Primary gaps / mismatches
                      (repo)                    baseline

                                                                    Needs explicit trust boundary
                      Inbound auth policy
 Email                                          DKIM/SPF/           assumptions; policy alignment and
                      checks and optional
 authenticity                                   DMARC               reporting not fully evidenced in repo
                      DKIM in relay
                                                                    docs fetched here. 2

                                                Ed25519 (RFC        Strong direction; requires test vectors +
 Envelope             Ed25519 signatures
                                                8032) + JCS (RFC    cross-language canonicalization proof.
 signing              over canonical JSON
                                                8785)                18


 Agent
                      Intents + parameters                          Lacks ACL performatives, content
 messaging                                      FIPA ACL
                      + delegation chains                           language/ontology negotiation. 14
 semantics

                                                                    Different object model and endpoint
 Federation           Node-to-node POST
                                                ActivityPub         semantics; requires adapter for
 model                delivery + receipts
                                                                    Fediverse interop. 15

                      Signatures +                                  No DID-based identity model; E2E
 Secure
                      (placeholder)             DIDComm v2          encryption packaging not clearly
 messaging
                      encryption flags                              complete. 4


Missing or incomplete features for a “new email protocol for agents”

 Capability                  Status in repo                        Why it matters for “agent email”

                                                                   Without a trustworthy root of identity
 Explicit trust anchor       Partially implicit (node_id/
                                                                   and node keys, federation authenticity
 (DNS/WebPKI/DID)            domain assumptions)
                                                                   breaks under adversaries.

 Key rotation and            Partial (key sets exist; revocation   Long-lived messaging networks require
 revocation story            not clearly end-to-end)               rotation and revocation at scale.

                             Not clearly complete (envelope        Agents often exchange sensitive data;
 End-to-end encryption
                             has encrypted flag; no full           confidentiality is mandatory in many
 profile
                             DIDComm-like packing)                 deployments.

                                                                   Email clients and MTAs rely heavily on
                             Partial/minimal parsing/
 Full MIME fidelity                                                MIME; partial fidelity causes loss and
                             rendering
                                                                   parsing vulnerabilities.

                                                                   New messaging networks get spammed;
 Comprehensive spam/
                             Not present as full pipeline          email history shows transport-only
 content filtering
                                                                   defenses are insufficient. 19

                                                                   Federation at scale needs shared signals
 Federated reputation        Local heuristics, configurable
                                                                   and tooling similar to email reputation
 ecosystem                   policies
                                                                   ecosystems.




                                                      13
 Capability                     Status in repo                  Why it matters for “agent email”

                                                                A protocol only becomes “real” when
 Multi-implementation
                                Not evidenced                   multiple independent implementations
 interoperability suite
                                                                interoperate reliably. 17


Prioritized action plan with effort estimates

 Priority     Action                     Effort   Rationale and concrete repo touchpoints

              Define and
                                                  Federation and remote identity validation rely on node
              implement the trust
                                                  keys and node_id/domain assumptions
              anchor for nodes
 P0                                      High     ( getNodeDocument ,
              and identities (DNS/
                                                  verifyRemoteIdentityDocumentSignature ,
              WebPKI binding, or
                                                  bootstrapFederationNode ).
              DID-based binding)

              Make node/system
              signing keys stable                 initializeSystemSigningKeys() auto-generates
 P0           across restarts and        High     keys; production must load from secret manager and
              define rotation/                    support rotation without breaking verification/audit.
              revocation

              Publish
              canonicalization +
                                                  Canonical JSON and signatures are core; RFC 8785 and
 P0           signature test             Medium
                                                  RFC 8032 style interoperability needs proof. 20
              vectors and add
              conformance tests

              Harden email
              ingress/egress:
              robust MIME parsing,
                                                  createBridgeInboundEnvelope , parseRfc822 ,
              strict header
 P0                                      High     outbound renderers and DSN updates depend on
              handling, explicit
                                                  correct email semantics. 21
              trust boundary for
              Authentication-
              Results

              Implement an E2E
              encryption profile
                                                  “Agent email” often requires confidentiality; DIDComm
 P1           (or explicitly scope it    High
                                                  provides reference packaging. 22
              out) and key
              agreement model

              Separate store.js
              into modules: core                  Improves maintainability/testability and reduces
 P1                                      Medium
              protocol engine vs                  security regression risk.
              adapters vs policy




                                                    14
     Priority        Action                       Effort      Rationale and concrete repo touchpoints

                     Add durable
                                                               searchEnvelopes is linear; state grows unbounded
     P1              indexing/search and          Medium
                                                              without retention policies.
                     retention controls

                     Expand IMAP
                     compatibility or
                     clearly brand as                         Current IMAP subset will break some clients; align with
     P1                                           Medium
                     “subset gateway”                         RFC 9051 behaviors or document limitations. 11
                     with client
                     compatibility matrix

                     Add a standard
                     adapter layer for
     P2                                           Medium      Enables broader agent ecosystem adoption.     23
                     ActivityPub/FIPA ACL
                     mappings (optional)

                     Formalize compliance
                     controls: retention,                     Needed for enterprise/GDPR readiness; current design
     P2              deletion, encryption         Medium      stores headers, bodies, attachments, and audit
                     at rest, audit access                    payloads.
                     segregation


File availability notes

The user requested specific files. The following were not present or not retrievable in the repo evaluation:
- server.js and store.js at repository root: not found (the implementation lives in src/node/
server.js               and    src/node/store.js ). -      src/node/postgres_adapter.js : not found (Postgres
persistence is in               src/node/persistence_postgres.js ). -            docs/RATE-LIMIT-POLICY.md : tool
retrieval was blocked in this environment during attempted fetch; analysis relied on code-level rate
limiting and quotas in src/node/store.js instead.



 1        6   9    10   19    https://www.rfc-editor.org/rfc/rfc5321.html
https://www.rfc-editor.org/rfc/rfc5321.html

 2    https://www.rfc-editor.org/rfc/rfc9051.html
https://www.rfc-editor.org/rfc/rfc9051.html

 3     17     20   https://www.rfc-editor.org/rfc/rfc8785
https://www.rfc-editor.org/rfc/rfc8785

 4    https://posomas.isse.de/PosoMAS/aose.core.tech.common.base/guidances/concepts/
       22

agent_communication_language_3392A674.html
https://posomas.isse.de/PosoMAS/aose.core.tech.common.base/guidances/concepts/
agent_communication_language_3392A674.html

 5        7   13   21   https://www.rfc-editor.org/rfc/rfc5322
https://www.rfc-editor.org/rfc/rfc5322




                                                                 15
 8   https://www.rfc-editor.org/info/std76
https://www.rfc-editor.org/info/std76

11   https://www.rfc-editor.org/info/rfc6376
https://www.rfc-editor.org/info/rfc6376

12   https://www.w3.org/TR/activitypub/
https://www.w3.org/TR/activitypub/

14   https://agent-skills.md/skills/cosmix/claude-loom/threat-model
https://agent-skills.md/skills/cosmix/claude-loom/threat-model

15   23   https://www.rfc-editor.org/rfc/rfc1939
https://www.rfc-editor.org/rfc/rfc1939

16   18   https://www.rfc-editor.org/rfc/rfc8032
https://www.rfc-editor.org/rfc/rfc8032




                                                                 16
